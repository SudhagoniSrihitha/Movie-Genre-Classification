# -*- coding: utf-8 -*-
"""Movie Genre Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XXXtiE1xR3aibm9qBGspQOrJ8XYZx9ib
"""

# --- Library Imports ---
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report
import re

def load_data(filepath, is_train=True):
    # --- Data Loading Function ---
    data = []
    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            parts = line.strip().split(' ::: ')
            if is_train:
                if len(parts) == 4:
                    data.append({
                        'ID': parts[0],
                        'TITLE': parts[1],
                        'GENRE': parts[2],
                        'DESCRIPTION': parts[3]
                    })
                else:
                    print(f"Skipping malformed training line: {line.strip()}")
            else:
                if len(parts) == 3:
                    data.append({
                        'ID': parts[0],
                        'TITLE': parts[1],
                        'DESCRIPTION': parts[2]
                    })
                else:
                    print(f"Skipping malformed test line: {line.strip()}")
    return pd.DataFrame(data)

def preprocess_text(text):
    # --- Text Preprocessing Function ---
    text = text.lower()
    text = re.sub(r'[^a-z\s]', '', text)
    return text

def main():
    # --- Data Loading ---
    print("Loading training and test data...")
    try:
        train_df = load_data('/content/train_data.txt', is_train=True)
        test_df = load_data('/content/test_data.txt', is_train=False)
        test_solution_df = load_data('/content/test_data_solution.txt', is_train=True)
    except FileNotFoundError as e:
        print(f"Error loading file: {e}. Please ensure train_data.txt, test_data.txt, and test_data_solution.txt are in the same directory.")
        return

    if train_df.empty or test_df.empty or test_solution_df.empty:
        print("One or more dataframes are empty. Exiting.")
        return

    print(f"Train data loaded: {len(train_df)} entries")
    print(f"Test data loaded: {len(test_df)} entries")
    print(f"Test solution data loaded: {len(test_solution_df)} entries")

    # --- Data Preprocessing ---
    print("Preprocessing text data...")
    train_df['CLEANED_DESCRIPTION'] = train_df['DESCRIPTION'].apply(preprocess_text)
    test_df['CLEANED_DESCRIPTION'] = test_df['DESCRIPTION'].apply(preprocess_text)
    test_solution_df['CLEANED_DESCRIPTION'] = test_solution_df['DESCRIPTION'].apply(preprocess_text)

    X_train_text = train_df['CLEANED_DESCRIPTION']
    y_train = train_df['GENRE']
    X_test_text = test_df['CLEANED_DESCRIPTION']
    y_test_solution = test_solution_df['GENRE']

    # --- Feature Extraction ---
    print("Extracting features using TF-IDF...")
    tfidf_vectorizer = TfidfVectorizer(max_features=5000, min_df=5, max_df=0.8)
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train_text)
    X_test_tfidf = tfidf_vectorizer.transform(X_test_text)

    print(f"TF-IDF features extracted. Training data shape: {X_train_tfidf.shape}")
    print(f"Test data shape: {X_test_tfidf.shape}")

    # --- Model Training ---
    print("Training Logistic Regression model...")
    classifier = LogisticRegression(random_state=42, solver='liblinear', max_iter=1000)
    classifier.fit(X_train_tfidf, y_train)
    print("Model training complete.")

    # --- Prediction ---
    print("Making predictions on test data...")
    y_pred = classifier.predict(X_test_tfidf)
    test_df['PREDICTED_GENRE'] = y_pred

    print("\n--- Predictions for Test Data (first 10) ---")
    print(test_df[['ID', 'TITLE', 'DESCRIPTION', 'PREDICTED_GENRE']].head(10).to_string())

    # --- Model Evaluation ---
    print("\n--- Model Evaluation ---")
    if len(y_pred) == len(y_test_solution):
        accuracy = accuracy_score(y_test_solution, y_pred)
        print(f"Accuracy: {accuracy:.4f}")
        print("\nClassification Report:")
        print(classification_report(y_test_solution, y_pred, zero_division=0))
    else:
        print("Mismatch in number of test predictions and solution entries. Cannot perform full evaluation.")
        print(f"Predicted entries: {len(y_pred)}, Solution entries: {len(y_test_solution)}")

if __name__ == "__main__":
    main()











